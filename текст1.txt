Базовый код для моторов

#!/usr/bin/env python3
import bluetooth
import RPi.GPIO as GPIO
import pigpio
import time
import threading

# Настройка GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Пины моторов
LEFT_IN1 = 17
LEFT_IN2 = 18
LEFT_ENA = 12
RIGHT_IN3 = 27
RIGHT_IN4 = 22
RIGHT_ENB = 13
SERVO_PIN = 26

# Инициализация
GPIO.setup([LEFT_IN1, LEFT_IN2, LEFT_IN3, LEFT_IN4], GPIO.OUT)
GPIO.setup([LEFT_ENA, RIGHT_ENB], GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)

pi = pigpio.pi()
pi.set_servo_pulsewidth(SERVO_PIN, 0)  # Сервопривод выкл

# PWM для моторов
left_pwm = GPIO.PWM(LEFT_ENA, 1000)
right_pwm = GPIO.PWM(RIGHT_ENB, 1000)
left_pwm.start(0)
right_pwm.start(0)

# Позиции сервопривода
SERVO_OPEN = 150  # Захват открыт (~1500us)
SERVO_CLOSE = 100 # Захват закрыт (~1000us)

def set_motors(left_speed, right_speed):
    """Управление моторами: скорость -1000..1000"""
    # Левый мотор
    if left_speed > 0:
        GPIO.output(LEFT_IN1, GPIO.HIGH)
        GPIO.output(LEFT_IN2, GPIO.LOW)
        left_pwm.ChangeDutyCycle(min(abs(left_speed), 100))
    elif left_speed < 0:
        GPIO.output(LEFT_IN1, GPIO.LOW)
        GPIO.output(LEFT_IN2, GPIO.HIGH)
        left_pwm.ChangeDutyCycle(min(abs(left_speed), 100))
    else:
        GPIO.output(LEFT_IN1, GPIO.LOW)
        GPIO.output(LEFT_IN2, GPIO.LOW)
        left_pwm.ChangeDutyCycle(0)
    
    # Правый мотор
    if right_speed > 0:
        GPIO.output(RIGHT_IN3, GPIO.HIGH)
        GPIO.output(RIGHT_IN4, GPIO.LOW)
        right_pwm.ChangeDutyCycle(min(abs(right_speed), 100))
    elif right_speed < 0:
        GPIO.output(RIGHT_IN3, GPIO.LOW)
        GPIO.output(RIGHT_IN4, GPIO.HIGH)
        right_pwm.ChangeDutyCycle(min(abs(right_speed), 100))
    else:
        GPIO.output(RIGHT_IN3, GPIO.LOW)
        GPIO.output(RIGHT_IN4, GPIO.LOW)
        right_pwm.ChangeDutyCycle(0)

def servo_grip(open=True):
    """Управление захватом"""
    if open:
        pi.set_servo_pulsewidth(SERVO_PIN, SERVO_OPEN * 10)
    else:
        pi.set_servo_pulsewidth(SERVO_PIN, SERVO_CLOSE * 10)

def handle_client(sock):
    """Обработка клиента"""
    try:
        while True:
            data = sock.recv(1024).decode('utf-8').strip()
            if not data:
                break
            
            print(f"Получена команда: {data}")
            
            if data == 'W':  # Вперед
                set_motors(80, 80)
            elif data == 'S':  # Назад
                set_motors(-80, -80)
            elif data == 'A':  # Влево
                set_motors(-60, 60)
            elif data == 'D':  # Вправо
                set_motors(60, -60)
            elif data == 'X':  # Стоп
                set_motors(0, 0)
            elif data == 'G':  # Захват
                servo_grip(False)
            elif data == 'R':  # Расхват
                servo_grip(True)
                
    except Exception as e:
        print(f"Ошибка: {e}")
    finally:
        set_motors(0, 0)
        pi.set_servo_pulsewidth(SERVO_PIN, 0)
        sock.close()

def bluetooth_server():
    """Bluetooth сервер"""
    server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    server_sock.bind(("", bluetooth.PORT_ANY))
    server_sock.listen(1)
    
    port = server_sock.getsockname()[1]
    uuid = "94f39d29-7d6d-437d-973b-fba39e49d4ee"
    
    bluetooth.advertise_service(server_sock, "RobotControl",
                               service_id=uuid,
                               service_classes=[uuid, bluetooth.SERIAL_PORT_CLASS],
                               profiles=[bluetooth.SERIAL_PORT_PROFILE])
    
    print(f"Ожидание подключения на порт {port}...")
    print("UUID: ", uuid)
    
    while True:
        client_sock, client_info = server_sock.accept()
        print(f"Подключен {client_info}")
        client_thread = threading.Thread(target=handle_client, args=(client_sock,))
        client_thread.daemon = True
        client_thread.start()

if __name__ == "__main__":
    try:
        bluetooth_server()
    except KeyboardInterrupt:
        print("\nОстановка...")
    finally:
        set_motors(0, 0)
        pi.set_servo_pulsewidth(SERVO_PIN, 0)
        left_pwm.stop()
        right_pwm.stop()
        pi.stop()
        GPIO.cleanup()



Базовый код для серво

#!/usr/bin/env python3
import pigpio
import time
import threading

# Пин сервопривода
SERVO_PIN = 26

# Позиции (настройте под ваш серво!)
SERVO_OPEN = 150   # Открыт (примерно 1500μs)
SERVO_CLOSE = 100  # Закрыт (примерно 1000μs)

# Глобальные переменные состояния
pi = None
current_position = SERVO_OPEN
is_moving = False
target_position = SERVO_OPEN

def init_servo():
    """Инициализация сервопривода"""
    global pi
    pi = pigpio.pi()
    if not pi.connected:
        exit("Не удалось подключиться к pigpiod")
    
    pi.set_servo_pulsewidth(SERVO_PIN, 0)  # Выключить
    print("Сервопривод инициализирован")

def set_servo_position(position):
    """Установка позиции (100-200 для pigpio)"""
    global current_position, target_position
    target_position = max(50, min(250, position))  # Ограничения
    print(f"Целевая позиция: {target_position}")

def smooth_move():
    """Плавное движение к цели"""
    global current_position, target_position, is_moving
    
    step = 5
    while abs(current_position - target_position) > step:
        if current_position < target_position:
            current_position += step
        else:
            current_position -= step
        
        pi.set_servo_pulsewidth(SERVO_PIN, current_position * 10)
        time.sleep(0.05)
    
    # Точная позиция
    current_position = target_position
    pi.set_servo_pulsewidth(SERVO_PIN, current_position * 10)
    is_moving = False
    print(f"Достигнута позиция: {current_position}")

def grip_open():
    """Открыть захват"""
    global is_moving
    if not is_moving:
        is_moving = True
        move_thread = threading.Thread(target=lambda: set_servo_position(SERVO_OPEN))
        move_thread.daemon = True
        move_thread.start()
        print("Открываем захват...")

def grip_close():
    """Закрыть захват"""
    global is_moving
    if not is_moving:
        is_moving = True
        move_thread = threading.Thread(target=lambda: set_servo_position(SERVO_CLOSE))
        move_thread.daemon = True
        move_thread.start()
        print("Закрываем захват...")

# ===== МЕСТО ДЛЯ ВАШИХ КОМАНД =====
# Пример: подключение к Bluetooth или веб-серверу
def handle_command(command):
    """Обработчик команд - ЗАМЕНИТЕ НА СВОЙ КОД"""
    command = command.upper().strip()
    
    if command == 'OPEN':      # Ваша команда открытия
        grip_open()
    elif command == 'CLOSE':   # Ваша команда закрытия
        grip_close()
    elif command == 'G':       # Короткая команда захвата
        grip_close()
    elif command == 'R':       # Короткая команда раскрытия
        grip_open()
    else:
        print(f"Неизвестная команда: {command}")

# Пример тестового цикла команд



Код для opencv

#!/usr/bin/env python3
import cv2
import numpy as np
import picamera2
from picamera2 import Picamera2
import imutils
import time

# HSV диапазоны для калибровки (красный пример)
lower_color = np.array([0, 100, 100])    # Hue Min, Sat Min, Val Min
upper_color = np.array([10, 255, 255])   # Hue Max, Sat Max, Val Max

# ===== КАЛИБРОВКА ЦВЕТА =====
def nothing(x):
    pass

def create_trackbars():
    """Создает трекбары для калибровки HSV"""
    cv2.namedWindow("Trackbars")
    cv2.resizeWindow("Trackbars", 640, 300)
    cv2.createTrackbar("Hue Min", "Trackbars", lower_color[0], 179, nothing)
    cv2.createTrackbar("Hue Max", "Trackbars", upper_color[0], 179, nothing)
    cv2.createTrackbar("Sat Min", "Trackbars", lower_color[1], 255, nothing)
    cv2.createTrackbar("Sat Max", "Trackbars", upper_color[1], 255, nothing)
    cv2.createTrackbar("Val Min", "Trackbars", lower_color[2], 255, nothing)
    cv2.createTrackbar("Val Max", "Trackbars", upper_color[2], 255, nothing)

def get_trackbar_values():
    """Читает значения трекбаров"""
    global lower_color, upper_color
    lower_color = np.array([
        cv2.getTrackbarPos("Hue Min", "Trackbars"),
        cv2.getTrackbarPos("Sat Min", "Trackbars"),
        cv2.getTrackbarPos("Val Min", "Trackbars")
    ])
    upper_color = np.array([
        cv2.getTrackbarPos("Hue Max", "Trackbars"),
        cv2.getTrackbarPos("Sat Max", "Trackbars"),
        cv2.getTrackbarPos("Val Max", "Trackbars")
    ])

# ===== ОПРЕДЕЛЕНИЕ ФОРМЫ =====
def get_shape(contour):
    """Определяет форму контура"""
    peri = cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, 0.04 * peri, True)
    
    # Центр контура
    M = cv2.moments(contour)
    if M["m00"] != 0:
        cx = int(M["m10"] / M["m00"])
        cy = int(M["m01"] / M["m00"])
    else:
        cx, cy = 0, 0
    
    # Форма по количеству углов
    sides = len(approx)
    if sides == 3:
        shape = "Треугольник"
    elif sides == 4:
        (x, y, w, h) = cv2.boundingRect(approx)
        ar = w / float(h)
        if ar >= 0.95 and ar <= 1.05:
            shape = "Квадрат"
        else:
            shape = "Прямоугольник"
    else:
        ((cx_approx, cy_approx), radius) = cv2.minEnclosingCircle(approx)
        if radius / max(w, h) > 0.8:
            shape = "Круг"
        else:
            shape = f"{sides}-угольник"
    
    return shape, (cx, cy)

# ===== ОСНОВНОЙ ЦИКЛ =====
def main(calibrate=False):
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (640, 480)})
    picam2.configure(config)
    picam2.start()
    
    if calibrate:
        create_trackbars()
    
    fps_start = time.time()
    frame_count = 0
    
    while True:
        frame = picam2.capture_array()
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        frame = imutils.resize(frame, width=640)
        
        # HSV и маска
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        if calibrate:
            get_trackbar_values()
        
        mask = cv2.inRange(hsv, lower_color, upper_color)
        mask = cv2.erode(mask, None, iterations=2)
        mask = cv2.dilate(mask, None, iterations=2)
        
        # Контуры
        contours = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = imutils.grab_contours(contours)
        
        center_object = None
        max_area = 0
        
        # Поиск крупнейшего объекта по центру
        frame_center_x = frame.shape[1] // 2
        frame_center_y = frame.shape[0] // 2
        
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > 500:  # Минимальная площадь
                (x, y, w, h) = cv2.boundingRect(contour)
                contour_center_x = x + w // 2
                contour_center_y = y + h // 2
                
                # Близость к центру (в пределах 100px)
                dist_to_center = abs(contour_center_x - frame_center_x) + abs(contour_center_y - frame_center_y)
                
                if dist_to_center < 100 and area > max_area:
                    max_area = area
                    center_object = contour
        
        if center_object is not None:
            shape, (cx, cy) = get_shape(center_object)
            
            # Рисуем
            cv2.drawContours(frame, [center_object], -1, (0, 255, 0), 2)
            cv2.circle(frame, (cx, cy), 5, (0, 0, 255), -1)
            
            # Инфо об объекте
            info = f"Цвет: HSV({lower_color[0]}-{upper_color[0]}) Площадь: {max_area}"
            cv2.putText(frame, info, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
            cv2.putText(frame, f"Форма: {shape}", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
            cv2.putText(frame, f"Центр: ({cx}, {cy})", (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            
            print(f"Объект по центру: {shape}, площадь {max_area}, центр ({cx},{cy})")
        else:
            cv2.putText(frame, "Объект по центру НЕ обнаружен", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
        
        # FPS
        frame_count += 1
        if frame_count % 30 == 0:
            fps = 30 / (time.time() - fps_start)
            cv2.putText(frame, f"FPS: {fps:.1f}", (10, frame.shape[0] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            fps_start = time.time()
        
        cv2.imshow("Frame", frame)
        cv2.imshow("Mask", mask)
        
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('s'):  # Сохранить HSV значения
            print(f"Сохраните: lower={lower_color}, upper={upper_color}")
    
    cv2.destroyAllWindows()
    picam2.stop()

if __name__ == "__main__":
    print("Калибровка цвета? (y/n)")
    calibrate = input().lower() == 'y'
    main(calibrate)
